# 2026-02-28 — Rust FFI Foundation

## Session: Cargo Workspace + FFI-First Architecture

Implemented the Rust FFI foundation — the first end-to-end FFI loop replacing subprocess-per-keystroke with direct library calls.

**Built (4 phases)**:

1. **Cargo workspace** — `appmesh-core` (cdylib+rlib) with code from `~/.gh/voice` (eis.rs, keymap.rs). New `InputHandle` wraps D-Bus EIS handshake + libei into sync API. 8 C ABI symbols exported from `libappmesh_core.so`.

2. **appmesh-cli** — Binary with `appmesh type` and `appmesh key` subcommands, replacing standalone `ei-type` (coexistence, not replacement).

3. **PHP FFI integration** — `AppMeshFFI` lazy singleton in `server/appmesh-ffi.php`. Keyboard plugin tries FFI first (~0.05ms), falls back to ei-type subprocess (~50-100ms). Response indicates path: "(FFI)" vs "(subprocess)".

4. **AppMeshPort trait** — ARexx-style port trait with `InputPort` as first implementation. Port FFI uses JSON for args/results across C boundary. Functions: `appmesh_port_open`, `appmesh_port_execute`, `appmesh_port_free`.

**Key details**:
- D-Bus connection must stay alive (KWin invalidates EIS on disconnect) — `InputHandle` holds both
- Stale handle recovery: FFI detects -2 return, destroys instance, retries on next call
- `reis` fork: `markc/reis` branch `fix-empty-scm-rights` — monitor PR #18 for upstream merge
- tokio runtime: single-threaded, created+dropped per `appmesh_init()` call only

**Files**: 15 new, 2 modified. 55 MCP tools load cleanly. All FFI tests pass.

## Session: Port Expansion + Real-World Testing

Verified the FFI end-to-end: installed `appmesh` CLI to PATH, tested keyboard tools through MCP server — both report "(FFI)" path. Confirmed graceful degradation to "(subprocess)" when .so is renamed away.

**New ports added** (proving the AppMeshPort trait pattern):
- **ClipboardPort** — Klipper get/set via zbus, pure FFI, round-trip verified
- **WindowsPort** — KWin window list/activate. Uses KWin script → callDBus → Klipper stash pattern (scripts can't return data via D-Bus). Saves/restores clipboard around the stash.
- **NotifyPort** — freedesktop Notifications D-Bus, pure FFI. First visible proof of the stack — desktop notification from PHP FFI → Rust → zbus → Plasma.

**Key fix**: tokio runtime must be kept alive per-port (not created+dropped per call). Creating a new runtime inside a D-Bus call deadlocks because zbus connection is bound to the original runtime.

**Installed**: wmctrl (but it only sees Xwayland windows, not useful on pure Wayland). KWin script approach is the right one for Wayland.

## Session: Shared QML Plugin + Two Plasmoids

Refactored the QML plugin from a compiled-in executable module to a shared library installable to the system QML path. Created two Plasma 6 plasmoids that demonstrate inter-widget messaging through a singleton bridge.

**Changes (4 modified, 4 new files)**:

1. **CMakeLists.txt rewrite** — Split into `appmeshplugin` (SHARED QML module) + `appmesh-app` (standalone test). Install targets: plugin → `/usr/lib/qt6/qml/AppMesh/` (queried via `qmake6`), plasmoids → `~/.local/share/plasma/plasmoids/`.

2. **AppMeshBridge singleton + messaging** — Added `QML_SINGLETON`, `meshMessage(channel, data)` signal, `sendMessage(channel, data)` slot. All plasmoids in plasmashell share one QML engine → one singleton → signals cross instantly (no IPC). Fixed library search path (removed `CMAKE_SOURCE_DIR` macro, hardcoded `~/.gh/appmesh/target/release/`).

3. **Mesh Send plasmoid** (`com.appmesh.send`) — Panel widget with text field, Broadcast button (sends mesh message), Notify button (fires desktop notification + broadcasts). ~65 lines QML.

4. **Mesh Log plasmoid** (`com.appmesh.log`) — Panel widget with scrolling message list, timestamp + channel + body per entry, badge count on compact icon, Clear button. ~75 lines QML.

**Key discovery**: Plasma/plasmawindowed only searches the system QML path (`/usr/lib/qt6/qml/`), not `~/.local/lib/qt6/qml/`. Install must target the system path (requires sudo).

**Verified**: Both plasmoids load in `plasmawindowed`, Mesh Send broadcasts appear in Mesh Log with timestamps, Notify button fires desktop notification AND broadcasts. Library loads via FFI ("AppMesh connected").
