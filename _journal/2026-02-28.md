# 2026-02-28 — Rust FFI Foundation

## Session: Cargo Workspace + FFI-First Architecture

Implemented the Rust FFI foundation — the first end-to-end FFI loop replacing subprocess-per-keystroke with direct library calls.

**Built (4 phases)**:

1. **Cargo workspace** — `appmesh-core` (cdylib+rlib) with code from `~/.gh/voice` (eis.rs, keymap.rs). New `InputHandle` wraps D-Bus EIS handshake + libei into sync API. 8 C ABI symbols exported from `libappmesh_core.so`.

2. **appmesh-cli** — Binary with `appmesh type` and `appmesh key` subcommands, replacing standalone `ei-type` (coexistence, not replacement).

3. **PHP FFI integration** — `AppMeshFFI` lazy singleton in `server/appmesh-ffi.php`. Keyboard plugin tries FFI first (~0.05ms), falls back to ei-type subprocess (~50-100ms). Response indicates path: "(FFI)" vs "(subprocess)".

4. **AppMeshPort trait** — ARexx-style port trait with `InputPort` as first implementation. Port FFI uses JSON for args/results across C boundary. Functions: `appmesh_port_open`, `appmesh_port_execute`, `appmesh_port_free`.

**Key details**:
- D-Bus connection must stay alive (KWin invalidates EIS on disconnect) — `InputHandle` holds both
- Stale handle recovery: FFI detects -2 return, destroys instance, retries on next call
- `reis` fork: `markc/reis` branch `fix-empty-scm-rights` — monitor PR #18 for upstream merge
- tokio runtime: single-threaded, created+dropped per `appmesh_init()` call only

**Files**: 15 new, 2 modified. 55 MCP tools load cleanly. All FFI tests pass.

## Session: Port Expansion + Real-World Testing

Verified the FFI end-to-end: installed `appmesh` CLI to PATH, tested keyboard tools through MCP server — both report "(FFI)" path. Confirmed graceful degradation to "(subprocess)" when .so is renamed away.

**New ports added** (proving the AppMeshPort trait pattern):
- **ClipboardPort** — Klipper get/set via zbus, pure FFI, round-trip verified
- **WindowsPort** — KWin window list/activate. Uses KWin script → callDBus → Klipper stash pattern (scripts can't return data via D-Bus). Saves/restores clipboard around the stash.
- **NotifyPort** — freedesktop Notifications D-Bus, pure FFI. First visible proof of the stack — desktop notification from PHP FFI → Rust → zbus → Plasma.

**Key fix**: tokio runtime must be kept alive per-port (not created+dropped per call). Creating a new runtime inside a D-Bus call deadlocks because zbus connection is bound to the original runtime.

**Installed**: wmctrl (but it only sees Xwayland windows, not useful on pure Wayland). KWin script approach is the right one for Wayland.

## Session: Shared QML Plugin + Two Plasmoids

Refactored the QML plugin from a compiled-in executable module to a shared library installable to the system QML path. Created two Plasma 6 plasmoids that demonstrate inter-widget messaging through a singleton bridge.

**Changes (4 modified, 4 new files)**:

1. **CMakeLists.txt rewrite** — Split into `appmeshplugin` (SHARED QML module) + `appmesh-app` (standalone test). Install targets: plugin → `/usr/lib/qt6/qml/AppMesh/` (queried via `qmake6`), plasmoids → `~/.local/share/plasma/plasmoids/`.

2. **AppMeshBridge singleton + messaging** — Added `QML_SINGLETON`, `meshMessage(channel, data)` signal, `sendMessage(channel, data)` slot. All plasmoids in plasmashell share one QML engine → one singleton → signals cross instantly (no IPC). Fixed library search path (removed `CMAKE_SOURCE_DIR` macro, hardcoded `~/.gh/appmesh/target/release/`).

3. **Mesh Send plasmoid** (`com.appmesh.send`) — Panel widget with text field, Broadcast button (sends mesh message), Notify button (fires desktop notification + broadcasts). ~65 lines QML.

4. **Mesh Log plasmoid** (`com.appmesh.log`) — Panel widget with scrolling message list, timestamp + channel + body per entry, badge count on compact icon, Clear button. ~75 lines QML.

**Key discovery**: Plasma/plasmawindowed only searches the system QML path (`/usr/lib/qt6/qml/`), not `~/.local/lib/qt6/qml/`. Install must target the system path (requires sudo).

**Verified**: Both plasmoids load in `plasmawindowed`, Mesh Send broadcasts appear in Mesh Log with timestamps, Notify button fires desktop notification AND broadcasts. Library loads via FFI ("AppMesh connected").

## Session: AMP Specification Rewrite

Rewrote `AMP-AppMesh-Protocol-Specification.md` from 920 lines of fiction to 442 lines of ground truth. The original spec described a system that didn't exist — Tauri/Electron apps, npm/Composer SDKs, a 24-week phased roadmap with all boxes unchecked, fake directory trees (`ampd/`, `sdk-php/`, `sdk-js/`, `desktop/`).

**What the rewrite covers** (all backed by real code):
- 8 C ABI symbols, verbatim `AppMeshPort` trait, 5 Rust ports with actual commands
- 10 PHP MCP plugins / 56 tools (updated from stale 7/48 count)
- QML singleton bridge API + 2 plasmoids
- CLI with 4 subcommands
- 3-node WireGuard mesh (cachyos/mko/mmc) with real URLs and services
- Measured latency table: FFI 0.05ms, D-Bus 1ms, Unix socket 0.1ms est., WebSocket/WG 2ms est.

**Key additions:**
- **DNS-native addressing** — `[port].[app].[node].amp` (reversed from old `[node].[app].[port]`), maps directly to DNS hierarchy. PowerDNS already manages zones on all nodes.
- **Iteration path** — honest Done/Next/Vision sections replacing the fictional roadmap

**Preserved** from the original: ARexx analogy + comparison table, `AmpMessage` envelope class, JSON wire format, "PHP is the scripting language" argument, "transport is an implementation detail" principle.

**Cut**: Tauri/Electron desktop app, npm `@appmesh/client` JS SDK, Composer `appmesh/amp` PHP SDK, `ampd` Laravel Artisan daemon, MarkWeb browser extension, all fictional scenarios, "Claude Code Development Notes" section.

## Session: AMP Markdown Frontmatter Wire Format

Replaced the JSON wire format in §4 with a **markdown frontmatter** envelope — `---` delimited headers with an optional freeform body. Inspired by the "markweb = markdown web" principle: AMP messages are documents you can read, not data structures you decode.

**Design decisions:**
- **`---` delimiters** borrowed from the static site ecosystem (Hugo, Jekyll, Statamic) — universally understood
- **Flat `key: value` headers** — looks like YAML but intentionally restricted, no indentation, no nesting, no YAML parser needed
- **`args:` and `json:` carry inline JSON** — leverages existing `serde_json` / `json_decode`, zero new dependencies
- **8-bit UTF-8 encoding** — JSON requires it, markdown expects it, modern transports handle it
- Investigated full YAML (Statamic/Hugo precedent) but rejected — YAML parser dependency and type coercion surprises not worth it for one structured field

**Three message shapes**, one parser:

| Shape | Example | Use case |
|---|---|---|
| **Full message** | Headers + markdown body | Events, rich responses, notifications |
| **Command** | Headers with `args: {...}` JSON, no body | Requests, acks |
| **Data** | Minimal `json: {...}` header | High-throughput streams |
| **Empty** | `---\n---\n` (8 bytes) | Heartbeat, ACK, NOP, stream separator |

**Grammar:** `message = "---\n" headers "---\n" body` — mandatory trailing `\n` for unambiguous stream framing.

**Key insight:** the `json:` shape means the format degrades gracefully to near-pure JSON streaming when routing context is already established by the transport, while the full shape carries human-readable markdown. Best of both worlds.

**Spec changes:** §4 rewritten with 7 subsections (Grammar, Three Shapes, Format, Header Fields, Examples, Parsing, Design Rationale). §10 Technical Decisions table updated. Working parser examples in both PHP and Rust.
