# 2026-02-28 — Rust FFI Foundation

## Session: Cargo Workspace + FFI-First Architecture

Implemented the Rust FFI foundation — the first end-to-end FFI loop replacing subprocess-per-keystroke with direct library calls.

**Built (4 phases)**:

1. **Cargo workspace** — `appmesh-core` (cdylib+rlib) with code from `~/.gh/voice` (eis.rs, keymap.rs). New `InputHandle` wraps D-Bus EIS handshake + libei into sync API. 8 C ABI symbols exported from `libappmesh_core.so`.

2. **appmesh-cli** — Binary with `appmesh type` and `appmesh key` subcommands, replacing standalone `ei-type` (coexistence, not replacement).

3. **PHP FFI integration** — `AppMeshFFI` lazy singleton in `server/appmesh-ffi.php`. Keyboard plugin tries FFI first (~0.05ms), falls back to ei-type subprocess (~50-100ms). Response indicates path: "(FFI)" vs "(subprocess)".

4. **AppMeshPort trait** — ARexx-style port trait with `InputPort` as first implementation. Port FFI uses JSON for args/results across C boundary. Functions: `appmesh_port_open`, `appmesh_port_execute`, `appmesh_port_free`.

**Key details**:
- D-Bus connection must stay alive (KWin invalidates EIS on disconnect) — `InputHandle` holds both
- Stale handle recovery: FFI detects -2 return, destroys instance, retries on next call
- `reis` fork: `markc/reis` branch `fix-empty-scm-rights` — monitor PR #18 for upstream merge
- tokio runtime: single-threaded, created+dropped per `appmesh_init()` call only

**Files**: 15 new, 2 modified. 55 MCP tools load cleanly. All FFI tests pass.

## Session: Port Expansion + Real-World Testing

Verified the FFI end-to-end: installed `appmesh` CLI to PATH, tested keyboard tools through MCP server — both report "(FFI)" path. Confirmed graceful degradation to "(subprocess)" when .so is renamed away.

**New ports added** (proving the AppMeshPort trait pattern):
- **ClipboardPort** — Klipper get/set via zbus, pure FFI, round-trip verified
- **WindowsPort** — KWin window list/activate. Uses KWin script → callDBus → Klipper stash pattern (scripts can't return data via D-Bus). Saves/restores clipboard around the stash.
- **NotifyPort** — freedesktop Notifications D-Bus, pure FFI. First visible proof of the stack — desktop notification from PHP FFI → Rust → zbus → Plasma.

**Key fix**: tokio runtime must be kept alive per-port (not created+dropped per call). Creating a new runtime inside a D-Bus call deadlocks because zbus connection is bound to the original runtime.

**Installed**: wmctrl (but it only sees Xwayland windows, not useful on pure Wayland). KWin script approach is the right one for Wayland.
